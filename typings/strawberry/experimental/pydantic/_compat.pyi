"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable
from dataclasses import dataclass
from functools import cached_property
from typing import Any, TYPE_CHECKING
from pydantic import BaseModel

if TYPE_CHECKING:
    ...
IS_PYDANTIC_V2: bool = ...
IS_PYDANTIC_V1: bool = ...
@dataclass
class CompatModelField:
    name: str
    type_: Any
    outer_type_: Any
    default: Any
    default_factory: Callable[[], Any] | None
    required: bool
    alias: str | None
    allow_none: bool
    has_alias: bool
    description: str | None
    _missing_type: Any
    is_v1: bool
    @property
    def has_default_factory(self) -> bool:
        ...
    
    @property
    def has_default(self) -> bool:
        ...
    


ATTR_TO_TYPE_MAP = ...
ATTR_TO_TYPE_MAP_Pydantic_V2 = ...
ATTR_TO_TYPE_MAP_Pydantic_Core_V2 = ...
def get_fields_map_for_v2() -> dict[Any, Any]:
    ...

class PydanticV2Compat:
    @property
    def PYDANTIC_MISSING_TYPE(self) -> Any:
        ...
    
    def get_model_computed_fields(self, model: type[BaseModel]) -> dict[str, CompatModelField]:
        ...
    
    def get_model_fields(self, model: type[BaseModel], include_computed: bool = ...) -> dict[str, CompatModelField]:
        ...
    
    @cached_property
    def fields_map(self) -> dict[Any, Any]:
        ...
    
    def get_basic_type(self, type_: Any) -> type[Any]:
        ...
    
    def model_dump(self, model_instance: BaseModel) -> dict[Any, Any]:
        ...
    


class PydanticV1Compat:
    @property
    def PYDANTIC_MISSING_TYPE(self) -> Any:
        ...
    
    def get_model_fields(self, model: type[BaseModel], include_computed: bool = ...) -> dict[str, CompatModelField]:
        """`include_computed` is a noop for PydanticV1Compat."""
        ...
    
    @cached_property
    def fields_map(self) -> dict[Any, Any]:
        ...
    
    def get_basic_type(self, type_: Any) -> type[Any]:
        ...
    
    def model_dump(self, model_instance: BaseModel) -> dict[Any, Any]:
        ...
    


class PydanticCompat:
    def __init__(self, is_v2: bool) -> None:
        ...
    
    @classmethod
    def from_model(cls, model: type[BaseModel]) -> PydanticCompat:
        ...
    
    def __getattr__(self, name: str) -> Any:
        ...
    


if IS_PYDANTIC_V2:
    def is_new_type(type_: Any) -> bool:
        ...
    
    def new_type_supertype(type_: Any) -> Any:
        ...
    
else:
    ...
__all__ = ["PydanticCompat", "get_args", "get_origin", "is_new_type", "lenient_issubclass", "new_type_supertype", "smart_deepcopy"]
