"""
This type stub file was generated by pyright.
"""

import builtins
from collections.abc import Callable, Sequence
from typing import Any, TypeVar, overload
from typing_extensions import dataclass_transform
from .field import StrawberryField, field

T = TypeVar("T", bound=builtins.type)
@overload
@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def type(cls: T, *, name: str | None = ..., is_input: bool = ..., is_interface: bool = ..., description: str | None = ..., directives: Sequence[object] | None = ..., extend: bool = ...) -> T:
    ...

@overload
@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def type(*, name: str | None = ..., is_input: bool = ..., is_interface: bool = ..., description: str | None = ..., directives: Sequence[object] | None = ..., extend: bool = ...) -> Callable[[T], T]:
    ...

def type(cls: T | None = ..., *, name: str | None = ..., is_input: bool = ..., is_interface: bool = ..., description: str | None = ..., directives: Sequence[object] | None = ..., extend: bool = ...) -> T | Callable[[T], T]:
    """Annotates a class as a GraphQL type.

    Similar to `dataclasses.dataclass`, but with additional functionality for
    defining GraphQL types.

    Args:
        cls: The class we want to create a GraphQL type from.
        name: The name of the GraphQL type.
        is_input: Whether the class is an input type. Used internally, use `@strawerry.input` instead of passing this flag.
        is_interface: Whether the class is an interface. Used internally, use `@strawerry.interface` instead of passing this flag.
        description: The description of the GraphQL type.
        directives: The directives of the GraphQL type.
        extend: Whether the class is extending an existing type.

    Returns:
        The class.

    Example usage:

    ```python
    @strawberry.type
    class User:
        name: str = "A name"
    ```

    You can also pass parameters to the decorator:

    ```python
    @strawberry.type(name="UserType", description="A user type")
    class MyUser:
        name: str = "A name"
    ```
    """
    ...

@overload
@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def input(cls: T, *, name: str | None = ..., one_of: bool | None = ..., description: str | None = ..., directives: Sequence[object] | None = ...) -> T:
    ...

@overload
@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def input(*, name: str | None = ..., one_of: bool | None = ..., description: str | None = ..., directives: Sequence[object] | None = ...) -> Callable[[T], T]:
    ...

def input(cls: T | None = ..., *, name: str | None = ..., one_of: bool | None = ..., description: str | None = ..., directives: Sequence[object] | None = ...):
    """Annotates a class as a GraphQL Input type.

    Similar to `@strawberry.type`, but for input types.

    Args:
        cls: The class we want to create a GraphQL input type from.
        name: The name of the GraphQL input type.
        description: The description of the GraphQL input type.
        directives: The directives of the GraphQL input type.
        one_of: Whether the input type is a `oneOf` type.

    Returns:
        The class.

    Example usage:

    ```python
    @strawberry.input
    class UserInput:
        name: str
    ```

    You can also pass parameters to the decorator:

    ```python
    @strawberry.input(name="UserInputType", description="A user input type")
    class MyUserInput:
        name: str
    ```
    """
    ...

@overload
@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def interface(cls: T, *, name: str | None = ..., description: str | None = ..., directives: Sequence[object] | None = ...) -> T:
    ...

@overload
@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def interface(*, name: str | None = ..., description: str | None = ..., directives: Sequence[object] | None = ...) -> Callable[[T], T]:
    ...

@dataclass_transform(order_default=True, kw_only_default=True, field_specifiers=(field, StrawberryField))
def interface(cls: T | None = ..., *, name: str | None = ..., description: str | None = ..., directives: Sequence[object] | None = ...):
    """Annotates a class as a GraphQL Interface.

    Similar to `@strawberry.type`, but for interfaces.

    Args:
        cls: The class we want to create a GraphQL interface from.
        name: The name of the GraphQL interface.
        description: The description of the GraphQL interface.
        directives: The directives of the GraphQL interface.

    Returns:
        The class.

    Example usage:

    ```python
    @strawberry.interface
    class Node:
        id: str
    ```

    You can also pass parameters to the decorator:

    ```python
    @strawberry.interface(name="NodeType", description="A node type")
    class MyNode:
        id: str
    ```
    """
    ...

def asdict(obj: Any) -> dict[str, object]:
    """Convert a strawberry object into a dictionary.

    This wraps the dataclasses.asdict function to strawberry.

    Args:
        obj: The object to convert into a dictionary.

    Returns:
        A dictionary representation of the object.

    Example usage:

    ```python
    @strawberry.type
    class User:
        name: str
        age: int


    strawberry.asdict(User(name="Lorem", age=25))
    # {"name": "Lorem", "age": 25}
    ```
    """
    ...

__all__ = ["StrawberryObjectDefinition", "asdict", "input", "interface", "type"]
