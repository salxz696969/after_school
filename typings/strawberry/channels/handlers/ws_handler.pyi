"""
This type stub file was generated by pyright.
"""

import datetime
from typing import TYPE_CHECKING, TypeGuard, TypedDict
from strawberry.http.async_base_view import AsyncBaseHTTPView, AsyncWebSocketAdapter
from strawberry.http.typevars import Context, RootValue
from .base import ChannelsWSConsumer
from collections.abc import AsyncGenerator, Mapping, Sequence
from strawberry.http import GraphQLHTTPResponse
from strawberry.schema import BaseSchema

if TYPE_CHECKING:
    ...
class ChannelsWebSocketAdapter(AsyncWebSocketAdapter):
    def __init__(self, view: AsyncBaseHTTPView, request: GraphQLWSConsumer, response: GraphQLWSConsumer) -> None:
        ...
    
    async def iter_json(self, *, ignore_parsing_errors: bool = ...) -> AsyncGenerator[object, None]:
        ...
    
    async def send_json(self, message: Mapping[str, object]) -> None:
        ...
    
    async def close(self, code: int, reason: str) -> None:
        ...
    


class MessageQueueData(TypedDict):
    message: str | None
    disconnected: bool
    ...


class GraphQLWSConsumer(ChannelsWSConsumer, AsyncBaseHTTPView["GraphQLWSConsumer", "GraphQLWSConsumer", "GraphQLWSConsumer", "GraphQLWSConsumer", "GraphQLWSConsumer", Context, RootValue,]):
    """A channels websocket consumer for GraphQL.

    This handles the connections, then hands off to the appropriate
    handler based on the subprotocol.

    To use this, place it in your ProtocolTypeRouter for your channels project, e.g:

    ```
    from strawberry.channels import GraphQLHttpRouter
    from channels.routing import ProtocolTypeRouter
    from django.core.asgi import get_asgi_application

    application = ProtocolTypeRouter({
        "http": URLRouter([
            re_path("^graphql", GraphQLHTTPRouter(schema=schema)),
            re_path("^", get_asgi_application()),
        ]),
        "websocket": URLRouter([
            re_path("^ws/graphql", GraphQLWebSocketRouter(schema=schema)),
        ]),
    })
    ```
    """
    websocket_adapter_class = ...
    def __init__(self, schema: BaseSchema, keep_alive: bool = ..., keep_alive_interval: float = ..., subscription_protocols: Sequence[str] = ..., connection_init_wait_timeout: datetime.timedelta | None = ...) -> None:
        ...
    
    async def connect(self) -> None:
        ...
    
    async def receive(self, text_data: str | None = ..., bytes_data: bytes | None = ...) -> None:
        ...
    
    async def disconnect(self, code: int) -> None:
        ...
    
    async def get_root_value(self, request: GraphQLWSConsumer) -> RootValue | None:
        ...
    
    async def get_context(self, request: GraphQLWSConsumer, response: GraphQLWSConsumer) -> Context:
        ...
    
    @property
    def allow_queries_via_get(self) -> bool:
        ...
    
    async def get_sub_response(self, request: GraphQLWSConsumer) -> GraphQLWSConsumer:
        ...
    
    def create_response(self, response_data: GraphQLHTTPResponse | list[GraphQLHTTPResponse], sub_response: GraphQLWSConsumer) -> GraphQLWSConsumer:
        ...
    
    async def render_graphql_ide(self, request: GraphQLWSConsumer) -> GraphQLWSConsumer:
        ...
    
    def is_websocket_request(self, request: GraphQLWSConsumer) -> TypeGuard[GraphQLWSConsumer]:
        ...
    
    async def pick_websocket_subprotocol(self, request: GraphQLWSConsumer) -> str | None:
        ...
    
    async def create_websocket_response(self, request: GraphQLWSConsumer, subprotocol: str | None) -> GraphQLWSConsumer:
        ...
    


__all__ = ["GraphQLWSConsumer"]
