"""
This type stub file was generated by pyright.
"""

import inspect
import builtins
from functools import cached_property
from typing import Any, ForwardRef, Generic, NamedTuple, TYPE_CHECKING, TypeVar
from typing_extensions import Protocol
from strawberry.annotation import StrawberryAnnotation
from strawberry.types.arguments import StrawberryArgument
from strawberry.types.base import StrawberryType
from collections.abc import Callable, Mapping

if TYPE_CHECKING:
    ...
class Parameter(inspect.Parameter):
    def __hash__(self) -> int:
        """Override to exclude default value from hash.

        This adds compatibility for using unhashable default values in resolvers such as
        list and dict. The present use-case is limited to analyzing parameters from one
        resolver. Therefore, the name, kind, and annotation combination are guaranteed
        to be unique since two arguments cannot have the same name in a callable.

        Furthermore, even though it is not currently a use-case to collect parameters
        from different resolvers, the likelihood of collision from having the same hash
        value but different defaults is mitigated by Python invoking the
        :py:meth:`__eq__` method if two items have the same hash. See the verification
        of this behavior in the `test_parameter_hash_collision` test.
        """
        ...
    


class Signature(inspect.Signature):
    _parameter_cls = Parameter


class ReservedParameterSpecification(Protocol):
    def find(self, parameters: tuple[inspect.Parameter, ...], resolver: StrawberryResolver[Any]) -> inspect.Parameter | None:
        """Finds the reserved parameter from ``parameters``."""
        ...
    


class ReservedName(NamedTuple):
    name: str
    def find(self, parameters: tuple[inspect.Parameter, ...], resolver: StrawberryResolver[Any]) -> inspect.Parameter | None:
        ...
    


class ReservedNameBoundParameter(NamedTuple):
    name: str
    def find(self, parameters: tuple[inspect.Parameter, ...], resolver: StrawberryResolver[Any]) -> inspect.Parameter | None:
        ...
    


class ReservedType(NamedTuple):
    """Define a reserved type by name or by type.

    To preserve backwards-comaptibility, if an annotation was defined but does not match
    :attr:`type`, then the name is used as a fallback if available.

    :attr:`alias` is the public name exposed in the `strawberry` module, if it differs
    from the internal class name (e.g. "Parent" for StrawberryParent).
    """
    name: str | None
    type: type
    alias: str | None = ...
    def find(self, parameters: tuple[inspect.Parameter, ...], resolver: StrawberryResolver[Any]) -> inspect.Parameter | None:
        ...
    
    def is_reserved_type(self, other: builtins.type | str | ForwardRef) -> bool:
        ...
    


SELF_PARAMSPEC = ...
CLS_PARAMSPEC = ...
ROOT_PARAMSPEC = ...
INFO_PARAMSPEC = ...
PARENT_PARAMSPEC = ...
T = TypeVar("T")
if hasattr(inspect, "markcoroutinefunction"):
    iscoroutinefunction = ...
else:
    iscoroutinefunction = ...
class StrawberryResolver(Generic[T]):
    RESERVED_PARAMSPEC: tuple[ReservedParameterSpecification, ...] = ...
    def __init__(self, func: Callable[..., T] | staticmethod | classmethod, *, description: str | None = ..., type_override: StrawberryType | type | None = ...) -> None:
        ...
    
    def __call__(self, *args: str, **kwargs: Any) -> T:
        ...
    
    @cached_property
    def signature(self) -> inspect.Signature:
        ...
    
    @cached_property
    def strawberry_annotations(self) -> dict[inspect.Parameter, StrawberryAnnotation | None]:
        ...
    
    @cached_property
    def reserved_parameters(self) -> dict[ReservedParameterSpecification, inspect.Parameter | None]:
        """Mapping of reserved parameter specification to parameter."""
        ...
    
    @cached_property
    def arguments(self) -> list[StrawberryArgument]:
        """Resolver arguments exposed in the GraphQL Schema."""
        ...
    
    @cached_property
    def info_parameter(self) -> inspect.Parameter | None:
        ...
    
    @cached_property
    def root_parameter(self) -> inspect.Parameter | None:
        ...
    
    @cached_property
    def self_parameter(self) -> inspect.Parameter | None:
        ...
    
    @cached_property
    def parent_parameter(self) -> inspect.Parameter | None:
        ...
    
    @cached_property
    def name(self) -> str:
        ...
    
    @cached_property
    def annotations(self) -> dict[str, object]:
        """Annotations for the resolver.

        Does not include special args defined in `RESERVED_PARAMSPEC` (e.g. self, root,
        info)
        """
        ...
    
    @cached_property
    def type_annotation(self) -> StrawberryAnnotation | None:
        ...
    
    @property
    def type(self) -> StrawberryType | type | None:
        ...
    
    @property
    def is_graphql_generic(self) -> bool:
        ...
    
    @cached_property
    def is_async(self) -> bool:
        ...
    
    def copy_with(self, type_var_map: Mapping[str, StrawberryType | builtins.type]) -> StrawberryResolver:
        ...
    


class UncallableResolverError(Exception):
    def __init__(self, resolver: StrawberryResolver) -> None:
        ...
    


__all__ = ["StrawberryResolver"]
