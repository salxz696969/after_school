"""
This type stub file was generated by pyright.
"""

import dataclasses
from collections.abc import AsyncIterable, AsyncIterator, Iterable, Iterator
from typing import Annotated, Any, ClassVar, Generic, Literal, TYPE_CHECKING, TypeAlias, TypeVar, overload
from typing_extensions import Self
from strawberry.types.info import Info
from strawberry.types.object_type import interface, type as strawberry_type
from strawberry.types.private import StrawberryPrivate
from strawberry.scalars import ID
from strawberry.utils.await_maybe import AwaitableOrValue

if TYPE_CHECKING:
    ...
_T = TypeVar("_T")
NodeIterableType: TypeAlias = (Iterator[_T] | Iterable[_T] | AsyncIterator[_T] | AsyncIterable[_T])
NodeType = TypeVar("NodeType", bound="Node")
PREFIX = ...
class GlobalIDValueError(ValueError):
    """GlobalID value error, usually related to parsing or serialization."""
    ...


@dataclasses.dataclass(order=True, frozen=True)
class GlobalID:
    """Global ID for relay types.

    Different from `strawberry.ID`, this ID wraps the original object ID in a string
    that contains both its GraphQL type name and the ID itself, and encodes it
    to a base64_ string.

    This object contains helpers to work with that, including method to retrieve
    the python object type or even the encoded node itself.

    Attributes:
        type_name:
            The type name part of the id
        node_id:
            The node id part of the id

    .. _base64:
        https://en.wikipedia.org/wiki/Base64

    """
    type_name: str
    node_id: str
    def __post_init__(self) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    @classmethod
    def from_id(cls, value: str | ID) -> Self:
        """Create a new GlobalID from parsing the given value.

        Args:
            value:
                The value to be parsed, as a base64 string in the
                "TypeName:NodeID" format

        Returns:
            An instance of GLobalID

        Raises:
            GlobalIDValueError:
                If the value is not in a GLobalID format

        """
        ...
    
    @overload
    async def resolve_node(self, info: Info, *, required: Literal[True] = ..., ensure_type: type[_T]) -> _T:
        ...
    
    @overload
    async def resolve_node(self, info: Info, *, required: Literal[True], ensure_type: None = ...) -> Node:
        ...
    
    @overload
    async def resolve_node(self, info: Info, *, required: bool = ..., ensure_type: None = ...) -> Node | None:
        ...
    
    async def resolve_node(self, info, *, required=..., ensure_type=...) -> Any:
        """Resolve the type name and node id info to the node itself.

        Tip: When you know the expected type, calling `ensure_type` should help
        not only to enforce it, but also help with typing since it will know that,
        if this function returns successfully, the retval should be of that
        type and not `Node`.

        Args:
            info:
                The strawberry execution info resolve the type name from
            required:
                If the value is required to exist. Note that asking to ensure
                the type automatically makes required true.
            ensure_type:
                Optionally check if the returned node is really an instance
                of this type.

        Returns:
            The resolved node

        Raises:
            TypeError:
                If ensure_type was provided and the type is not an instance of it

        """
        ...
    
    def resolve_type(self, info: Info) -> type[Node]:
        """Resolve the internal type name to its type itself.

        Args:
            info:
                The strawberry execution info resolve the type name from

        Returns:
            The resolved GraphQL type for the execution info

        """
        ...
    
    @overload
    def resolve_node_sync(self, info: Info, *, required: Literal[True] = ..., ensure_type: type[_T]) -> _T:
        ...
    
    @overload
    def resolve_node_sync(self, info: Info, *, required: Literal[True], ensure_type: None = ...) -> Node:
        ...
    
    @overload
    def resolve_node_sync(self, info: Info, *, required: bool = ..., ensure_type: None = ...) -> Node | None:
        ...
    
    def resolve_node_sync(self, info, *, required=..., ensure_type=...) -> Any:
        """Resolve the type name and node id info to the node itself.

        Tip: When you know the expected type, calling `ensure_type` should help
        not only to enforce it, but also help with typing since it will know that,
        if this function returns successfully, the retval should be of that
        type and not `Node`.

        Args:
            info:
                The strawberry execution info resolve the type name from
            required:
                If the value is required to exist. Note that asking to ensure
                the type automatically makes required true.
            ensure_type:
                Optionally check if the returned node is really an instance
                of this type.

        Returns:
            The resolved node

        Raises:
            TypeError:
                If ensure_type was provided and the type is not an instance of it

        """
        ...
    


class NodeIDPrivate(StrawberryPrivate):
    """Annotate a type attribute as its id.

    The `Node` interface will automatically create and resolve GlobalIDs
    based on the field annotated with `NodeID`. e.g:

    ```python
    import strawberry


    @strawberry.type
    class Fruit(Node):
        code: NodeID[str]
    ```

    In this case, `code` will be used to generate a global ID in the
    format `Fruit:<code>` and will be exposed as `id: GlobalID!` in the
    `Fruit` type.
    """
    ...


NodeID: TypeAlias = Annotated[_T, NodeIDPrivate()]
@interface(description="An object with a Globally Unique ID")
class Node:
    """Node interface for GraphQL types.

    Subclasses must type the id field using `NodeID`. It will be private to the
    schema because it will be converted to a global ID and exposed as `id: GlobalID!`

    The following methods can also be implemented:
        resolve_id:
            (Optional) Called to resolve the node's id. Can be overriden to
            customize how the id is retrieved (e.g. in case you don't want
            to define a `NodeID` field)
        resolve_nodes:
            Called to retrieve an iterable of node given their ids
        resolve_node:
            (Optional) Called to retrieve a node given its id. If not defined
            the default implementation will call `.resolve_nodes` with that
            single node id.

    Example:
    ```python
    import strawberry


    @strawberry.type
    class Fruit(strawberry.relay.Node):
        id: strawberry.relay.NodeID[int]
        name: str

        @classmethod
        def resolve_nodes(cls, *, info, node_ids, required=False):
            # Return an iterable of fruits in here
            ...
    ```
    """
    _id_attr: ClassVar[str | None] = ...
    @classmethod
    def resolve_id_attr(cls) -> str:
        ...
    
    @classmethod
    def resolve_id(cls, root: Self, *, info: Info) -> AwaitableOrValue[str]:
        """Resolve the node id.

        By default this will return `getattr(root, <id_attr>)`, where <id_attr>
        is the field typed with `NodeID`.

        You can override this method to provide a custom implementation.

        Args:
            info: The strawberry execution info resolve the type name from.
            root: The node to resolve.

        Returns:
            The resolved id (which is expected to be str)

        """
        ...
    
    @classmethod
    def resolve_typename(cls, root: Self, info: Info) -> str:
        ...
    
    @overload
    @classmethod
    def resolve_nodes(cls, *, info: Info, node_ids: Iterable[str], required: Literal[True]) -> AwaitableOrValue[Iterable[Self]]:
        ...
    
    @overload
    @classmethod
    def resolve_nodes(cls, *, info: Info, node_ids: Iterable[str], required: Literal[False] = ...) -> AwaitableOrValue[Iterable[Self | None]]:
        ...
    
    @overload
    @classmethod
    def resolve_nodes(cls, *, info: Info, node_ids: Iterable[str], required: bool) -> AwaitableOrValue[Iterable[Self]] | AwaitableOrValue[Iterable[Self | None]]:
        ...
    
    @classmethod
    def resolve_nodes(cls, *, info: Info, node_ids: Iterable[str], required: bool = ...):
        """Resolve a list of nodes.

        This method *should* be defined by anyone implementing the `Node` interface.

        The nodes should be returned in the same order as the provided ids.
        Also, if `required` is `True`, all ids must be resolved or an error
        should be raised. If `required` is `False`, missing nodes should be
        returned as `None`.

        Args:
            info: The strawberry execution info resolve the type name from.
            node_ids: List of node ids that should be returned.
            required: If `True`, all `node_ids` requested must exist. If they don't,
                an error must be raised. If `False`, missing nodes should be
                returned as `None`. It only makes sense when passing a list of
                `node_ids`, otherwise it will should ignored.

        Returns:
            An iterable of resolved nodes.

        """
        ...
    
    @overload
    @classmethod
    def resolve_node(cls, node_id: str, *, info: Info, required: Literal[True]) -> AwaitableOrValue[Self]:
        ...
    
    @overload
    @classmethod
    def resolve_node(cls, node_id: str, *, info: Info, required: Literal[False] = ...) -> AwaitableOrValue[Self | None]:
        ...
    
    @overload
    @classmethod
    def resolve_node(cls, node_id: str, *, info: Info, required: bool) -> AwaitableOrValue[Self | None]:
        ...
    
    @classmethod
    def resolve_node(cls, node_id: str, *, info: Info, required: bool = ...) -> AwaitableOrValue[Self | None]:
        """Resolve a node given its id.

        This method is a convenience method that calls `resolve_nodes` for
        a single node id.

        Args:
            info: The strawberry execution info resolve the type name from.
            node_id: The id of the node to be retrieved.
            required: if the node is required or not to exist. If not, then None
                should be returned if it doesn't exist. Otherwise an exception
                should be raised.

        Returns:
            The resolved node or None if it was not found
        """
        ...
    


@strawberry_type(description="Information to aid in pagination.")
class PageInfo:
    """Information to aid in pagination.

    Attributes:
        has_next_page:
            When paginating forwards, are there more items?
        has_previous_page:
            When paginating backwards, are there more items?
        start_cursor:
            When paginating backwards, the cursor to continue
        end_cursor:
            When paginating forwards, the cursor to continue
    """
    has_next_page: bool = ...
    has_previous_page: bool = ...
    start_cursor: str | None = ...
    end_cursor: str | None = ...


@strawberry_type(description="An edge in a connection.")
class Edge(Generic[NodeType]):
    """An edge in a connection.

    Attributes:
        cursor:
            A cursor for use in pagination
        node:
            The item at the end of the edge
    """
    cursor: str = ...
    node: NodeType = ...
    CURSOR_PREFIX: ClassVar[str] = ...
    @classmethod
    def resolve_edge(cls, node: NodeType, *, cursor: Any = ..., **kwargs: Any) -> Self:
        ...
    


@strawberry_type(description="A connection to a list of items.")
class Connection(Generic[NodeType]):
    """A connection to a list of items.

    Attributes:
        page_info:
            Pagination data for this connection
        edges:
            Contains the nodes in this connection

    """
    page_info: PageInfo = ...
    edges: list[Edge[NodeType]] = ...
    @classmethod
    def resolve_node(cls, node: Any, *, info: Info, **kwargs: Any) -> NodeType:
        """The identity function for the node.

        This method is used to resolve a node of a different type to the
        connection's `NodeType`.

        By default it returns the node itself, but subclasses can override
        this to provide a custom implementation.

        Args:
            node:
                The resolved node which should return an instance of this
                connection's `NodeType`.
            info:
                The strawberry execution info resolve the type name from.
            **kwargs:
                Additional arguments passed to the resolver.

        """
        ...
    
    @classmethod
    def resolve_connection(cls, nodes: NodeIterableType[NodeType], *, info: Info, before: str | None = ..., after: str | None = ..., first: int | None = ..., last: int | None = ..., max_results: int | None = ..., **kwargs: Any) -> AwaitableOrValue[Self]:
        """Resolve a connection from nodes.

        Subclasses must define this method to paginate nodes based
        on `first`/`last`/`before`/`after` arguments.

        Args:
            info: The strawberry execution info resolve the type name from.
            nodes: An iterable/iteretor of nodes to paginate.
            before: Returns the items in the list that come before the specified cursor.
            after: Returns the items in the list that come after the specified cursor.
            first: Returns the first n items from the list.
            last: Returns the items in the list that come after the specified cursor.
            max_results: The maximum number of results to resolve.
            kwargs: Additional arguments passed to the resolver.

        Returns:
            The resolved `Connection`

        """
        ...
    


@strawberry_type(name="Connection", description="A connection to a list of items.")
class ListConnection(Connection[NodeType]):
    """A connection to a list of items.

    Attributes:
        page_info:
            Pagination data for this connection
        edges:
            Contains the nodes in this connection

    """
    page_info: PageInfo = ...
    edges: list[Edge[NodeType]] = ...
    @classmethod
    def resolve_connection(cls, nodes: NodeIterableType[NodeType], *, info: Info, before: str | None = ..., after: str | None = ..., first: int | None = ..., last: int | None = ..., max_results: int | None = ..., **kwargs: Any) -> AwaitableOrValue[Self]:
        """Resolve a connection from the list of nodes.

        This uses the described Relay Pagination algorithm_

        Args:
            info: The strawberry execution info resolve the type name from.
            nodes: An iterable/iteretor of nodes to paginate.
            before: Returns the items in the list that come before the specified cursor.
            after: Returns the items in the list that come after the specified cursor.
            first: Returns the first n items from the list.
            last: Returns the items in the list that come after the specified cursor.
            max_results: The maximum number of results to resolve.
            kwargs: Additional arguments passed to the resolver.

        Returns:
            The resolved `Connection`

        .. _Relay Pagination algorithm:
            https://relay.dev/graphql/connections.htm#sec-Pagination-algorithm
        """
        ...
    


__all__ = ["PREFIX", "Connection", "Edge", "GlobalID", "GlobalIDValueError", "ListConnection", "Node", "NodeID", "NodeIDAnnotationError", "NodeIDPrivate", "NodeIterableType", "NodeType", "PageInfo"]
